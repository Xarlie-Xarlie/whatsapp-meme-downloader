# Processamento de V√≠deo

## ‚úÇÔ∏è Vis√£o Geral da Funcionalidade

O Sistema de Processamento de V√≠deo √© respons√°vel pela segmenta√ß√£o, otimiza√ß√£o e prepara√ß√£o de v√≠deos baixados para diferentes usos, especialmente para compatibilidade com WhatsApp Status (limitado a 30 segundos) e otimiza√ß√£o de envio.

## üèóÔ∏è Arquitetura e Posicionamento

### Posi√ß√£o na Arquitetura
- **Camada**: L√≥gica de Neg√≥cio/Processamento
- **Responsabilidade**: Transforma√ß√£o e otimiza√ß√£o de m√≠dia
- **Depend√™ncias**: FFmpeg, Sistema de Arquivos, Workers

### M√≥dulos Relacionados
- `src/consumer/segment_video.js` - Segmenta√ß√£o principal
- `src/consumer/video_to_preview.js` - Gera√ß√£o de previews
- `src/workers/cutter.js` - Worker de segmenta√ß√£o
- `src/workers/video_preview.js` - Worker de preview
- `src/bot/list_status_videos.js` - Listagem inteligente

## üéØ Prop√≥sito e L√≥gica de Neg√≥cio

### Prop√≥sito Principal
Transformar v√≠deos baixados em formatos otimizados para diferentes contextos de uso, garantindo compatibilidade com limita√ß√µes do WhatsApp e melhor experi√™ncia do usu√°rio.

### Valor de Neg√≥cio
- ‚úÖ **Compatibilidade**: V√≠deos prontos para WhatsApp Status
- ‚úÖ **Otimiza√ß√£o**: Redu√ß√£o de tempo de envio
- ‚úÖ **Flexibilidade**: M√∫ltiplos formatos de sa√≠da
- ‚úÖ **Qualidade**: Preserva√ß√£o da qualidade original

## üîÑ Fluxo de Trabalho Principal

### Processo de Segmenta√ß√£o Completo

```mermaid
sequenceDiagram
    participant DW as Download Worker
    participant Queue as RabbitMQ
    participant CW as Cutter Worker
    participant Segmenter as Video Segmenter
    participant FFprobe as FFprobe
    participant FFmpeg as FFmpeg
    participant FS as File System
    participant Bot as WhatsApp Bot
    
    DW->>Queue: Enfileira job segmenta√ß√£o
    Queue->>CW: Consome cutter_queue
    CW->>Segmenter: segmentVideoAtPath(payload)
    Segmenter->>FFprobe: Obter dura√ß√£o do v√≠deo
    FFprobe-->>Segmenter: Dura√ß√£o em segundos
    
    Segmenter->>Segmenter: Analisar necessidade de segmenta√ß√£o
    
    alt V√≠deo ‚â§ 30 segundos
        Segmenter-->>CW: Retorna sem segmentar
        CW-->>Bot: V√≠deo original pronto
    else V√≠deo > 30 segundos
        Segmenter->>Segmenter: Calcular n√∫mero de segmentos
        
        loop Para cada segmento
            Segmenter->>FS: Verificar se segmento existe
            alt Segmento n√£o existe
                Segmenter->>FFmpeg: Criar segmento
                FFmpeg->>FS: Salvar segmento
            else Segmento existe
                Segmenter->>Segmenter: Pular segmenta√ß√£o
            end
        end
        
        Segmenter-->>CW: Lista de segmentos criados
        CW-->>Bot: Segmentos prontos para envio
    end
```

### Fluxo de Decis√£o de Processamento

```mermaid
flowchart TD
    A[V√≠deo baixado] --> B[Obter dura√ß√£o via FFprobe]
    B --> C{Dura√ß√£o ‚â§ 30s?}
    C -->|Sim| D[Manter v√≠deo original]
    C -->|N√£o| E[Calcular n√∫mero de segmentos]
    E --> F[Segmentos = ceil(dura√ß√£o/30)]
    F --> G[Para cada segmento]
    G --> H{Arquivo j√° existe?}
    H -->|Sim| I[Pular segmenta√ß√£o]
    H -->|N√£o| J[Criar comando FFmpeg]
    J --> K[Executar segmenta√ß√£o]
    K --> L[Salvar segmento]
    L --> M{Mais segmentos?}
    M -->|Sim| G
    M -->|N√£o| N[Listar arquivos criados]
    I --> M
    D --> O[Enviar original]
    N --> P[Enviar segmentos]
    
    style A fill:#e1f5fe
    style O fill:#e8f5e8
    style P fill:#e8f5e8
```

## üìã Implementa√ß√£o T√©cnica Detalhada

### **Detec√ß√£o de Dura√ß√£o com FFprobe**
```javascript
async function getVideoDuration(inputPath) {
  return new Promise((resolve, reject) => {
    const command = `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 ${inputPath}`;
    
    child_process.exec(command, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error getting video duration: ${error.message}`);
        reject(error);
        return;
      }
      const duration = parseFloat(stdout.trim());
      resolve(duration);
    });
  });
}
```

### **Segmenta√ß√£o com FFmpeg**
```javascript
const command = `ffmpeg -ss ${startTime} -i ${inputPath} -t ${endTime - startTime} -c copy ${segmentOutputPath}`;

// Par√¢metros:
// -ss: Tempo inicial
// -i: Arquivo de entrada  
// -t: Dura√ß√£o do segmento
// -c copy: C√≥pia sem recodifica√ß√£o (preserva qualidade)
```

### **Nomenclatura de Segmentos**
```javascript
function generateSegmentName(fileName, partNumber) {
  return `${fileName}_part_${partNumber}.mp4`;
}

// Exemplo:
// Video: "ABC123.mp4" 
// Segmentos: "ABC123_part_0.mp4", "ABC123_part_1.mp4", etc.
```

## üèóÔ∏è Modelo de Dom√≠nio da Funcionalidade

### **Entidades Principais**

#### ‚úÇÔ∏è **Tarefa de Segmenta√ß√£o (SegmentationTask)**
- **Propriedades**:
  - `filePath`: Caminho do v√≠deo original
  - `duration`: Dura√ß√£o total em segundos
  - `segmentDuration`: Dura√ß√£o de cada segmento (30s)
  - `outputDirectory`: Diret√≥rio de sa√≠da
  - `segments`: Lista de segmentos criados

#### üé¨ **Segmento de V√≠deo (VideoSegment)**
- **Propriedades**:
  - `partNumber`: N√∫mero sequencial do segmento
  - `startTime`: Tempo inicial (segundos)
  - `endTime`: Tempo final (segundos)
  - `filePath`: Caminho do arquivo segmentado
  - `duration`: Dura√ß√£o real do segmento

#### üìä **An√°lise de V√≠deo (VideoAnalysis)**
- **Propriedades**:
  - `originalPath`: Caminho do arquivo original
  - `duration`: Dura√ß√£o total
  - `needsSegmentation`: Boolean para necessidade de segmenta√ß√£o
  - `estimatedSegments`: N√∫mero estimado de segmentos

### **Objetos de Valor**

#### ‚è±Ô∏è **Dura√ß√£o (Duration)**
```javascript
class Duration {
  constructor(seconds) {
    this.seconds = parseFloat(seconds);
    this.minutes = Math.floor(this.seconds / 60);
    this.remainingSeconds = this.seconds % 60;
  }
  
  needsSegmentation() {
    return this.seconds > 30;
  }
  
  calculateSegments() {
    return Math.ceil(this.seconds / 30);
  }
}
```

### **Regras de Neg√≥cio Espec√≠ficas**

#### **RN-VP001**: Crit√©rio de Segmenta√ß√£o
| Dura√ß√£o do V√≠deo | A√ß√£o | Justificativa |
|------------------|------|---------------|
| ‚â§ 30 segundos | Manter original | Compat√≠vel com WhatsApp Status |
| > 30 segundos | Segmentar em 30s | Otimizar para envio e uso |
| √öltimo segmento | Dura√ß√£o vari√°vel | Evitar segmentos muito pequenos |

#### **RN-VP002**: Preserva√ß√£o de Qualidade
```bash
# Comando FFmpeg utilizado
ffmpeg -ss {start} -i {input} -t {duration} -c copy {output}

# -c copy: Evita recodifica√ß√£o, preserva qualidade
# Resultado: Segmenta√ß√£o sem perda de qualidade
```

#### **RN-VP003**: Gest√£o de Duplicatas
- **Verifica√ß√£o**: Antes de cada segmenta√ß√£o
- **A√ß√£o**: Pular se arquivo j√° existe
- **Log**: "Segment {name} already exists. Skipping."

#### **RN-VP004**: Nomenclatura Consistente
- **Padr√£o**: `{nome_original}_part_{numero}.mp4`
- **Numera√ß√£o**: Sequencial a partir de 0
- **Zeros √† esquerda**: N√£o utilizados (0, 1, 2...)

## üîß Depend√™ncias e Integra√ß√µes

### **FFmpeg Integration**
```javascript
// Verifica√ß√£o de instala√ß√£o
const ffmpegCommand = 'ffmpeg -version';
const ffprobeCommand = 'ffprobe -version';

// Dockerfile
RUN apt-get install -y ffmpeg
```

### **Sistema de Workers**
```javascript
// Worker de segmenta√ß√£o
import consumer from '../consumer/consumer.js';
import segmentVideoAtPath from '../consumer/segment_video.js';

consumer('cutter_queue', segmentVideoAtPath, eventCallback);
```

### **Sistema de Arquivos**
```javascript
import fs from 'node:fs';
import path from 'node:path';

// Verifica√ß√£o de exist√™ncia
if (fs.existsSync(segmentOutputPath)) {
  console.log(`Segment ${segmentFileName} already exists. Skipping.`);
  continue;
}
```

## üé® Integra√ß√£o com Listagem Inteligente

### **Filtragem e Ordena√ß√£o**
```javascript
// src/bot/list_status_videos.js
function naturalSort(a, b) {
  const extractPartNumber = (str) => {
    const match = str.match(/_part_(\d+)/);
    return match ? parseInt(match[1]) : null;
  };
  
  const partNumberA = extractPartNumber(a);
  const partNumberB = extractPartNumber(b);
  
  // Ordena√ß√£o por nome base e n√∫mero de parte
  if (partNumberA < partNumberB) return -1;
  if (partNumberA > partNumberB) return 1;
  return 0;
}
```

### **Detec√ß√£o de V√≠deos Segmentados**
```javascript
function listStatusVideos(directory) {
  const files = fs.readdirSync(directory);
  let segmentedFiles = [];
  const originalFiles = {};
  
  files.forEach((file) => {
    const fileName = parse(file).name;
    const fileParts = fileName.split('_part_');
    
    if (fileParts.length > 1) {
      // √â um segmento
      const baseName = fileParts[0] + extname(file);
      if (!originalFiles[baseName]) {
        originalFiles[baseName] = true;
        segmentedFiles.push(baseName); // Adiciona original uma vez
      }
      segmentedFiles.push(file); // Adiciona segmento
    } else {
      // Arquivo n√£o segmentado
      segmentedFiles.push(file);
    }
  });
  
  return segmentedFiles
    .filter((file) => !originalFiles[file] && !file.includes('_compressed'))
    .map((file) => directory + file)
    .sort(naturalSort);
}
```

## ‚ö†Ô∏è Casos Extremos e Tratamento de Erros

### **Cen√°rios de Falha**

#### 1. **FFmpeg N√£o Instalado**
```javascript
// Detec√ß√£o
child_process.exec('ffmpeg -version', (error) => {
  if (error) {
    console.error('FFmpeg not found. Please install FFmpeg.');
    process.exit(1);
  }
});
```

#### 2. **Arquivo Original Corrompido**
```javascript
// Tratamento durante obten√ß√£o de dura√ß√£o
if (stderr) {
  console.error(`ffprobe stderr: ${stderr}`);
  reject(new Error('Video file might be corrupted'));
}
```

#### 3. **Espa√ßo Insuficiente**
```javascript
// Verifica√ß√£o antes da segmenta√ß√£o
try {
  const stats = fs.statSync(inputPath);
  const fileSize = stats.size;
  const availableSpace = getAvailableSpace('./videos/');
  
  if (availableSpace < fileSize * 2) {
    throw new Error('Insufficient disk space for segmentation');
  }
} catch (error) {
  console.error('Disk space check failed:', error);
}
```

#### 4. **Permiss√µes de Arquivo**
```javascript
// Verifica√ß√£o de permiss√µes
try {
  fs.accessSync(outputPath, fs.constants.W_OK);
} catch (error) {
  console.error('No write permission for output directory');
  throw error;
}
```

### **Recupera√ß√£o e Fallbacks**

#### **Segmenta√ß√£o Parcial**
- **Problema**: Falha em um segmento espec√≠fico
- **A√ß√£o**: Continuar com pr√≥ximos segmentos
- **Log**: Registrar segmento problem√°tico
- **Resultado**: Enviar segmentos v√°lidos

#### **Formato N√£o Suportado**
- **Problema**: FFmpeg n√£o consegue processar
- **A√ß√£o**: Enviar v√≠deo original
- **Log**: Registrar formato problem√°tico
- **Fallback**: Sem processamento adicional

## üìä M√©tricas e Monitoramento

### **M√©tricas de Processamento**
```javascript
// Logs implementados
console.log(`Video ${fileName} is less than or equal to 30 seconds. Skipping segmentation.`);
console.log(`Segmented ${fileName} into 30-second parts.`);
console.log(`Segment ${segmentFileName} already exists. Skipping.`);
```

### **KPIs do Sistema**
- **Taxa de Segmenta√ß√£o**: V√≠deos segmentados / V√≠deos processados
- **Tempo M√©dio de Segmenta√ß√£o**: Por segundo de v√≠deo original
- **Taxa de Aproveitamento**: Segmentos reutilizados vs. criados
- **Qualidade Preservada**: Verifica√ß√£o de integridade p√≥s-segmenta√ß√£o

### **Alertas Operacionais**
- ‚ö†Ô∏è FFmpeg indispon√≠vel
- ‚ö†Ô∏è Tempo de segmenta√ß√£o > 5x dura√ß√£o original
- ‚ö†Ô∏è Taxa de falhas > 5%
- ‚ö†Ô∏è Espa√ßo em disco < 2x maior arquivo

## üîÆ Casos de Uso Avan√ßados

### **Processamento de V√≠deos Longos**
```javascript
// V√≠deo de 5 minutos (300s)
// Resultado: 10 segmentos de 30s cada
const duration = 300;
const segments = Math.ceil(duration / 30); // 10 segmentos

for (let i = 0; i < segments; i++) {
  const startTime = i * 30;
  const endTime = Math.min((i + 1) * 30, duration);
  // √öltimo segmento: 270s-300s = 30s completos
}
```

### **Otimiza√ß√£o de Qualidade**
```javascript
// Futura implementa√ß√£o com an√°lise de qualidade
async function optimizeForWhatsApp(inputPath) {
  const analysis = await analyzeVideo(inputPath);
  
  if (analysis.bitrate > WHATSAPP_MAX_BITRATE) {
    return compressVideo(inputPath, WHATSAPP_OPTIMAL_SETTINGS);
  }
  
  return inputPath; // Usar original se j√° otimizado
}
```

## üöÄ Melhorias Futuras

### **Curto Prazo**
- üìä An√°lise de qualidade pr√©-segmenta√ß√£o
- üîß Configura√ß√£o de dura√ß√£o de segmento
- üì± Diferentes perfis para diferentes tipos de conte√∫do

### **M√©dio Prazo**
- üé¨ Gera√ß√£o de previews e thumbnails
- ü§ñ Detec√ß√£o autom√°tica de cenas para cortes inteligentes
- üìà Otimiza√ß√£o baseada em feedback de qualidade

### **Longo Prazo**
- üß† IA para otimiza√ß√£o de pontos de corte
- ‚òÅÔ∏è Processamento distribu√≠do para v√≠deos muito longos
- üé® Aplica√ß√£o de filtros e efeitos autom√°ticos